using UnityEngine;
using UnityEditor;
using System.Reflection;
using System.Text;
using System.IO;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Security.Cryptography;

public static class WrapperGenerator
{
    [MenuItem("Tools/Generate Wrappers")]
    public static void GenerateWrappers()
    {
        Assembly assembly = Assembly.Load("Assembly-CSharp");
        var allTypes = assembly.GetTypes().Where(w=>w.Name== "MainMono")
            .ToList();

        foreach (Type type in allTypes)
        {
            GenerateWrapperClass(type);
        }

        AssetDatabase.Refresh();
    }

    private static void GenerateWrapperClass(Type targetType)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"// Auto generated by WrapperGenerator.cs at time:{System.DateTime.Now}");
        HashSet<string> requiredNamespaces = new HashSet<string>();
        // Add UnityEngine.Pool for ListPool
        requiredNamespaces.Add("System.Reflection");
        requiredNamespaces.Add("UnityEngine");
        requiredNamespaces.Add("UnityEngine.Pool");

        // Collect all required namespaces
        CollectNamespaces(targetType, requiredNamespaces);

        // Add using directives
        foreach (string ns in requiredNamespaces.OrderBy(n => n))
        {
            sb.AppendLine($"using {ns};");
        }

        if (requiredNamespaces.Count > 0) sb.AppendLine();

        // Add namespace
        if (!string.IsNullOrEmpty(targetType.Namespace))
        {
            sb.AppendLine($"namespace {targetType.Namespace} {{");
        }

        sb.AppendLine($"public class {targetType.Name}Wrapper : UnityEngine.MonoBehaviour {{");

        // Get assembly and class name (with proper escaping)
        string assemblyName = targetType.Assembly.GetName().Name.Replace("\"", "\\\"");
        string classFullName = targetType.FullName?.Replace("\"", "\\\"") ?? string.Empty;

        // Add the new fields
        sb.AppendLine($"    public static readonly string assemblyName = \"{assemblyName}\";");
        sb.AppendLine($"    public static readonly string classFullName = \"{classFullName}\";");
        sb.AppendLine();

        sb.AppendLine($"    private System.Object _targetMapping;");
        sb.AppendLine();
        //sb.AppendLine($"    public {targetType.Name}Wrapper({typeof(System.Object).FullName} target) {{");
        //sb.AppendLine($"        _targetMapping = new {nameof(InvocationMapping)}(target);");
        //sb.AppendLine("    }");
        //sb.AppendLine();




        // SetTarget method instead of constructor
        sb.AppendLine($"    public void SetTarget({typeof(System.Object).FullName} target) {{");
        sb.AppendLine($"        _targetMapping = target;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Custom Awake method
        sb.AppendLine(@"    public void Awake()
    {
        using var _ = ListPool<Component>.Get(out var components);
        GetComponents(components);
        foreach(var c in components)
        {
            var tp = c.GetType();
            if (tp.FullName == classFullName && tp.Assembly.GetName().Name == assemblyName)
            {
                SetTarget(c);
                break;
            }
        }
    }");

        sb.AppendLine(@"    public void AddWrapComponent()
    {
        var type = Type.GetType($""{classFullName}, {assemblyName}"");
        if (type != null)
        {
            this.gameObject.AddComponent(type);
        }
    }");

        sb.AppendLine();

        // Generate method wrappers
        foreach (MethodInfo method in targetType.GetMethods(
            BindingFlags.Public | BindingFlags.Instance)
            .Where(m => !m.IsSpecialName))
        {
            if (method.IsGenericMethod 
                || HasOutOrRefParameters(method) 
                || IsDeclaredInUntiyMono(method))
            {
                continue;
            }
            GenerateMethodWrapper(targetType, sb, method);
        }

        // Generate property wrappers
        foreach (PropertyInfo property in targetType.GetProperties(
            BindingFlags.Public | BindingFlags.Instance))
        {
            if (IsDeclaredInUntiyMono(property))
            {
                continue;
            }
            GeneratePropertyWrapper(targetType, sb, property);
        }

        // Generate field wrappers
        foreach (FieldInfo field in targetType.GetFields(
            BindingFlags.Public | BindingFlags.Instance))
        {
            if (IsDeclaredInUntiyMono(field))
            {
                continue;
            }
            GenerateFieldWrapper(sb, field);
        }

        sb.AppendLine("}");

        if (!string.IsNullOrEmpty(targetType.Namespace))
        {
            sb.AppendLine("}");
        }

        SaveToFile(targetType.Name + "Wrapper.cs", sb.ToString());
    }

    private static bool HasOutOrRefParameters(MethodInfo method)
    {
        ParameterInfo[] parameters = method.GetParameters();
        foreach (ParameterInfo parameter in parameters)
        {
            if (parameter.ParameterType.IsByRef && (parameter.IsOut || parameter.IsIn))
            {
                return true;
            }
        }
        return false;
    }

    private static bool IsDeclaredInUntiyMono(MemberInfo member)
    {
        Type declaringType = member.DeclaringType;
        return declaringType == typeof(UnityEngine.MonoBehaviour) 
            || declaringType == typeof(UnityEngine.Behaviour) 
            || declaringType == typeof(UnityEngine.Component) 
            || declaringType == typeof(UnityEngine.Object) 
            || declaringType == typeof(System.Object);
    }

    private static void CollectNamespaces(Type targetType, HashSet<string> namespaces)
    {
        string targetNamespace = targetType.Namespace;
        var alreadyChecked = new HashSet<Type>();

        // Methods
        foreach (MethodInfo method in targetType.GetMethods(
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .Where(m => !m.IsSpecialName))
        {
            AddTypeNamespaces(method.ReturnType, namespaces, targetNamespace, alreadyChecked);
            foreach (ParameterInfo param in method.GetParameters())
            {
                AddTypeNamespaces(param.ParameterType, namespaces, targetNamespace, alreadyChecked);
            }
        }

        // Properties
        foreach (PropertyInfo property in targetType.GetProperties(
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
        {
            AddTypeNamespaces(property.PropertyType, namespaces, targetNamespace, alreadyChecked);
        }

        // Fields
        foreach (FieldInfo field in targetType.GetFields(
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
        {
            AddTypeNamespaces(field.FieldType, namespaces, targetNamespace, alreadyChecked);
        }
    }

    private static void AddTypeNamespaces(Type type, HashSet<string> namespaces, string targetNamespace, HashSet<Type> alreadyChecked)
    {
        if (type == null || alreadyChecked.Contains(type)) return;
        alreadyChecked.Add(type);

        // Handle arrays
        if (type.IsArray)
        {
            AddTypeNamespaces(type.GetElementType(), namespaces, targetNamespace, alreadyChecked);
            return;
        }

        // Handle generics
        if (type.IsGenericType)
        {
            foreach (Type genericArg in type.GetGenericArguments())
            {
                AddTypeNamespaces(genericArg, namespaces, targetNamespace, alreadyChecked);
            }
            AddTypeNamespaces(type.GetGenericTypeDefinition(), namespaces, targetNamespace, alreadyChecked);
        }

        // Add namespace if valid
        if (!string.IsNullOrEmpty(type.Namespace) &&
            type.Namespace != targetNamespace &&
            !namespaces.Contains(type.Namespace))
        {
            namespaces.Add(type.Namespace);
        }
    }







    private static void GenerateFieldWrapper(StringBuilder sb, FieldInfo field)
    {
        string _fieldInfo = $"_{field.Name}FieldInfo";
        sb.AppendLine($"    private FieldInfo {_fieldInfo};");


        sb.AppendLine($"    public {field.FieldType.FullName} {field.Name} {{");

        sb.AppendLine("        get {");
        sb.AppendLine();
        sb.AppendLine($"        if ({_fieldInfo} == null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            {_fieldInfo} = ");
        sb.AppendLine($"               _targetMapping.GetType().GetField(\"{field.Name}\",");
        sb.AppendLine($"                    BindingFlags.Public | BindingFlags.Instance);");
        sb.AppendLine("        }");


        sb.AppendLine($"        return ({GetTypeName(field.FieldType)}){_fieldInfo}.GetValue(_targetMapping);");
        sb.AppendLine();
        sb.AppendLine("        }");


        sb.AppendLine("        set {");
        sb.AppendLine();
        sb.AppendLine($"        if ({_fieldInfo} == null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            {_fieldInfo} = ");
        sb.AppendLine($"               _targetMapping.GetType().GetField(\"{field.Name}\",");
        sb.AppendLine($"                    BindingFlags.Public | BindingFlags.Instance);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"            {_fieldInfo}.SetValue(_targetMapping, value);");
        sb.AppendLine();
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void SaveToFile(string fileName, string content)
    {
        string path = Path.Combine(Application.dataPath, "AsmMono", "GeneratedWrappers", fileName);
        Directory.CreateDirectory(Path.GetDirectoryName(path));
        File.WriteAllText(path, content);
    }


























    private static void GeneratePropertyWrapper(Type targetType, StringBuilder sb, PropertyInfo property)
    {
        string delegateGetField = $"_{property.Name}PropertyGetDelegate";
        string delegateSetField = $"_{property.Name}PropertySetDelegate";

        string delegateTypeGet="";
        string delegateTypeSet="";
        if (property.CanRead)
        {
            delegateTypeGet = $"System.Func<{GetTypeName(property.GetGetMethod().ReturnType)}>";
            // Delegate field declaration
            sb.AppendLine($"    private {delegateTypeGet} {delegateGetField};");
        }
        if (property.CanWrite)
        {
            delegateTypeSet = $"System.Action<{GetTypeName(property.GetSetMethod().GetParameters()[0].ParameterType)}>";
            // Delegate field declaration
            sb.AppendLine($"    private {delegateTypeSet} {delegateSetField};");
        }


        sb.AppendLine($"    public {property.PropertyType.FullName} {property.Name} {{");
        if (property.CanRead)
        {


            sb.AppendLine("        get {");
            sb.AppendLine();
            sb.AppendLine($"        if ({delegateGetField} == null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            {delegateGetField} = ({delegateTypeGet})Delegate.CreateDelegate(");
            sb.AppendLine($"                typeof({delegateTypeGet}),");
            sb.AppendLine($"                _targetMapping,");
            sb.AppendLine($"               _targetMapping.GetType().GetProperty(\"{property.Name}\",");
            sb.AppendLine($"                    BindingFlags.Public | BindingFlags.Instance).GetGetMethod());");
            sb.AppendLine("        }");

         
            sb.AppendLine($"        return {delegateGetField}();");
            sb.AppendLine();
            sb.AppendLine("        }");
        }
        if (property.CanWrite)
        {
            string argumentList = GetTypeName(property.GetSetMethod().GetParameters()[0].ParameterType);

            sb.AppendLine("        set {");
            sb.AppendLine();


            sb.AppendLine($"        if ({delegateSetField} == null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            {delegateSetField} = ({delegateTypeSet})Delegate.CreateDelegate(");
            sb.AppendLine($"                typeof({delegateTypeSet}),");
            sb.AppendLine($"                _targetMapping,");
            sb.AppendLine($"               _targetMapping.GetType().GetProperty(\"{property.Name}\",");
            sb.AppendLine($"                    BindingFlags.Public | BindingFlags.Instance).GetSetMethod());");
            sb.AppendLine("        }");

            sb.AppendLine($"       {delegateSetField}(value);");

            sb.AppendLine();
            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }


    private static void GenerateMethodWrapper(Type targetType, StringBuilder sb, MethodInfo method)
    {
        string delegateType = GetDelegateTypeDeclaration(method);
        string delegateField = $"_{method.Name}Delegate";
        string parameterList = GetParameterList(method);
        string argumentList = GetArgumentList(method);
        // Delegate field declaration
        sb.AppendLine($"    private {delegateType} {delegateField};");





        string returnType = GetTypeName(method.ReturnType);
        string parameters = string.Join(", ", method.GetParameters()
            .Select(p => $"{GetTypeName(p.ParameterType)} {p.Name}"));
        string arguments = string.Join(", ",
            method.GetParameters().Select(p => p.Name));
        sb.AppendLine($"    public {returnType} {method.Name}({parameters}) {{");

        //var arg = !string.IsNullOrEmpty(arguments) ? $", {arguments}" : "";
        //if (method.ReturnType == typeof(void))
        //{
        //    sb.AppendLine($"        _targetMapping.InvokeMethod(\"{method.Name}\"{arg});");
        //}
        //else
        //{
        //    sb.AppendLine($"        return ({returnType})_targetMapping.InvokeMethod(\"{method.Name}\"{arg});");
        //}





        sb.AppendLine($"        if ({delegateField} == null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            {delegateField} = ({delegateType})Delegate.CreateDelegate(");
        sb.AppendLine($"                typeof({delegateType}),");
        sb.AppendLine($"                _targetMapping,");
        sb.AppendLine($"                _targetMapping.GetType().GetMethod(\"{method.Name}\",");
        sb.AppendLine($"                    BindingFlags.Public | BindingFlags.Instance));");
        sb.AppendLine("        }");

        if (method.ReturnType == typeof(void))
        {
            sb.AppendLine($"        {delegateField}({argumentList});");
        }
        else
        {
            sb.AppendLine($"        return {delegateField}({argumentList});");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GetTypeName(Type type)
    {
        if (type == typeof(void)) return "void";
        if (!type.IsGenericType) return type.FullName;

        string name = type.Name.Split('`')[0];
        IEnumerable<string> args = type.GetGenericArguments().Select(GetTypeName);
        return $"{name}<{string.Join(", ", args)}>";
    }


    private static string GetParameterList(MethodInfo method)
    {
        return string.Join(", ", method.GetParameters()
            .Select(p => $"{GetTypeName(p.ParameterType)} {p.Name}"));
    }

    private static string GetArgumentList(MethodInfo method)
    {
        return string.Join(", ", method.GetParameters()
            .Select(p => p.Name));
    }

    private static string GetDelegateTypeDeclaration(MethodInfo method)
    {
        var parameters = method.GetParameters()
            .Select(p => GetTypeName(p.ParameterType))
            .ToList();

        if (method.ReturnType == typeof(void))
        {
            if (parameters.Count == 0)
            {
                return $"System.Action";
            }
            return $"System.Action<{string.Join(", ", parameters)}>";
        }

        return $"System.Func<{string.Join(", ", parameters)}{(parameters.Count > 0 ? ", " : "")}{GetTypeName(method.ReturnType)}>";
    }
}